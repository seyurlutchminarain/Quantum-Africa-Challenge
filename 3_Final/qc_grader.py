from typing import Union
import numpy as np
from qiskit_nature.drivers import Molecule
from qiskit_nature.results.bopes_sampler_result import BOPESSamplerResult
from qiskit import QuantumCircuit
from qiskit.circuit.library.n_local import (
    NLocal,
    TwoLocal,
    RealAmplitudes,
    PauliTwoDesign,
    EfficientSU2,
    ExcitationPreserving,
    QAOAAnsatz,
)
from qiskit.circuit.library.n_local import __all__ as ANSATZ_NAMES
from enum import Enum
from functools import partial
from typing import Callable, Tuple, List, Optional


class MolecularVariation(Enum):
    absolute_stretching = 0
    relative_stretching = 1
    absolute_bending = 2
    relative_bending = 3


def molecularVariation_and_atom_pair_to_callable(
    moleculare_variation: MolecularVariation, atom_pair: tuple
):
    """Creates a callable from the MolecularVariation enum and an atom-pair tuple.

    Args:
        moleculare_variation (MolecularVariation): The molecular variation to use.
        atom_pair (tuple): The indices for the atoms defining a degree of freedom

    Raises:
        RuntimeError: If `molecular_variation` is of an unknown value.

    Returns:
        callable: a `functools.partial` instance calling `molecular_variation` with `atom_pair=atom_pair`.
    """

    if moleculare_variation == MolecularVariation.absolute_stretching:
        func = Molecule.absolute_stretching
    elif moleculare_variation == MolecularVariation.relative_stretching:
        func = Molecule.relative_stretching
    elif moleculare_variation == MolecularVariation.absolute_bending:
        func = Molecule.absolute_bending
    elif moleculare_variation == MolecularVariation.relative_bending:
        func = Molecule.relative_bending
    else:
        raise RuntimeError("molecular_variation is of an unknown value")

    return partial(func, atom_pair=atom_pair)


def callable_to_MolecularVariation_and_atom_pair(callable):
    """Reverses the operation of `apply_variation_to_atom_pair` from the third notebook. `callable` is converted from a `functools.partial` callable into an enum indicating which molecular variation was used and what the atom_pair is.

    Args:
        callable (functools.partial): A callable as generated by `apply_variation_to_atom_pair`

    Raises:
        RuntimeError: An error thrown if callable is not an instance of `functools.partial`.

    Returns:
        MolecularVariation: The type of molecular variation used as the base callable for the wrapped partial.
        atom_pair: The argument for the `atom_pair` keyword passed to the molecular variation callable.
    """
    if not isinstance(callable, partial):
        raise RuntimeError("callable must be an instance of functools.partial")

    # Get the original function
    func = callable.func
    args = callable.args
    keywords = callable.keywords

    if func == Molecule.absolute_stretching:
        moleculare_variation = MolecularVariation.absolute_stretching
    elif func == Molecule.relative_stretching:
        moleculare_variation = MolecularVariation.relative_stretching
    elif func == Molecule.absolute_bending:
        moleculare_variation = MolecularVariation.absolute_bending
    elif func == Molecule.relative_bending:
        moleculare_variation = MolecularVariation.relative_bending
    else:
        moleculare_variation = None

    atom_pair = keywords["atom_pair"]

    return moleculare_variation, atom_pair


def serialize_molecule(molecule: Molecule):
    """Takes a molecule instance and returns arguments that can recreate the molecule again using the following code from the third notebook.

    ```python
    specific_molecular_variation = apply_variation_to_atom_pair(molecular_variation, atom_pair=(1, 0))
    macro_molecule = Molecule(
        geometry=geometry,
        charge=charge,
        multiplicity=multiplicity,
        degrees_of_freedom=[specific_molecular_variation],
        masses=masses,
    )
    ```

    Args:
        molecule (Molecule): The qiskit molecule to serialize

    Returns:
        np.ndarray: molecule geometry
        int: multiplicity
        int: charge
        MolecularVariation: the molecular variation function used
        tuple: a tuple of indices for the geometry used with the molecular variation
        list: a list of masses for each atom in geometry
    """

    if len(molecule._degrees_of_freedom) != 1:
        raise NotImplementedError(
            "serialize_molecule does not currently support more than one degree of freedom"
        )

    molecular_variation, atom_pair = callable_to_MolecularVariation_and_atom_pair(
        molecule._degrees_of_freedom[0]
    )
    return (
        molecule._geometry,
        molecule.multiplicity,
        molecule.charge,
        molecular_variation,
        atom_pair,
        molecule.masses,
    )


def molecule_from_serialized_molecule(
    geometry,
    multiplicity,
    charge,
    molecular_variation,
    atom_pair,
    masses,
):
    """Create a `molecule` instance from the output of `serialize_molecule`.

    Args:
        geometry (np.ndarray): the atoms and their positions that make up the molecule
        multiplicity (int): The multiplicity of the molecule
        charge (int): the charge of the molecule
        molecular_variation (MolecularVariation): the variation used for the degree of freedom
        atom_pair (tuple): a tuple of indices identifying the atoms in `geometry` on which `molecular_variation` operates
        masses (list): list of masses of the atoms in the molecule

    Returns:
        [type]: [description]
    """
    specific_molecular_variation = molecularVariation_and_atom_pair_to_callable(
        molecular_variation, atom_pair
    )
    return Molecule(
        geometry=geometry,
        charge=charge,
        multiplicity=multiplicity,
        degrees_of_freedom=[specific_molecular_variation],
        masses=masses,
    )


def geometries_are_equal(geometry1, geometry2):
    """A helper function to compare geometry arrays, used by `qiskit_nature.drivers.Molecule`.

    Args:
        geometry1 (Union(list,np.ndarray)): Array describing the geometry of molecule1
        geometry2 (Union(list,np.ndarray)): Array describing the geometry of molecule2

    Returns:
        bool: True if the geometries match, false otherwise
    """
    if sorted(geometry1) != sorted(geometry2):
        return False

    return True


def atom_pairs_are_equal(geometry1, atompair1, geometry2, atompair2):
    """A helper function to compare atom_pair tuples, used by `qiskit_nature.drivers.Molecule`.

    Args:
        geometry1 (Union(list,np.ndarray)): Array describing the geometry of molecule1
        atompair1 (tuple): A tuple of indices referencing atoms in `geometry1`
        geometry2 (Union(list,np.ndarray)): Array describing the geometry of molecule2
        atompair2 (tuple): A tuple of indices referencing atoms in `geometry2`

    Returns:
        bool: True if the geometries and atom pairs match, false otherwise
    """
    # Check if geometries are equal
    if sorted(geometry1) != sorted(geometry2):
        return False

    # Check if atompairs are really pairs
    if len(atompair1) != len(atompair2):
        return False
    # Check if atoms referenced by atom pairs are the same
    for i1, i2 in zip(atompair1, atompair2):
        if geometry1[i1] != geometry2[i2]:
            return False
    return True


#####################################
# Exercise 1                        #
#####################################


def submit_ex1(
    geometry: List[Tuple[str, List[float]]],
    multiplicity: int,
    charge: int,
    molecular_variation: MolecularVariation,  # molecular_variation and atom_pair encode `degrees_of_freedom`
    atom_pair: tuple,
    masses: list,
):

    _sol_geometry = [
        ["C", [-0.1805, 1.3955, 0.0]],
        ["C", [0.0598, -0.3882, 0.0]],
        ["H", [-2.0305, -0.3861, -0.0001]],
        ["H", [-1.3085, 1.1864, 0.0001]],
        ["H", [-0.0014, -1.4883, -0.0001]],
        ["N", [-1.1878, 0.1791, 0.0]],
        ["O", [1.128, 0.2091, 0.0]],
    ]
    _sol_multiplicity = 1
    _sol_charge = 0
    _sol_atom_pair = (0, 5)
    _sol_molecular_variation = MolecularVariation.absolute_stretching

    ## Check if solution is correct
    # Check geometry and atom pair
    if not geometries_are_equal(_sol_geometry, geometry):
        return False, "Geometry is incorrect"

    # Check the atoms referenced by the atom pair indices
    if not atom_pairs_are_equal(_sol_geometry, _sol_atom_pair, geometry, atom_pair):
        return False, "Atom Pair is incorrect"

    if charge != _sol_charge:
        return False, "Charge is incorrect"

    if multiplicity != _sol_multiplicity:
        return False, "Multiplicity is incorrect"

    if molecular_variation != _sol_molecular_variation:
        return False, "Molecular Variation/Degrees of Freedom is incorrect"

    # Masses is not defined for the solution and thus must be checked if it is `none`.
    if masses is not None:
        return False, "Molecule atom masses are incorrect"

    return True, None


def grade_ex1(
    molecule: Molecule,
):
    if not isinstance(molecule, Molecule):
        print(f"ðŸ˜¢ Your answer is incorrect.")
        print(f"You didn't appear to pass a `Molecule` object instance.")
        return
    (
        geometry,
        multiplicity,
        charge,
        molecular_variation,
        atom_pair,
        masses,
    ) = serialize_molecule(molecule)
    correct, message = submit_ex1(
        geometry=geometry,
        multiplicity=multiplicity,
        charge=charge,
        molecular_variation=molecular_variation,
        atom_pair=atom_pair,
        masses=masses,
    )
    if not correct:
        print(f"ðŸ˜¢ Your answer is incorrect.")
        print(f"Message from grader: {message}")

    if correct:
        print(f"ðŸŒŸ Correct! Your macro-molecule is defined correctly!")


#####################################
# Exercise 2                        #
#####################################


def submit_ex2(q1_answer: str, q2_answer: str):
    _sol_q1_answers = ["above"]
    _sol_q2_answers = ["increases", "increase", "increased"]

    if q1_answer.lower() not in _sol_q1_answers:
        return False, "Your Q1 answer is incorrect"
    if q2_answer.lower() not in _sol_q2_answers:
        return False, "Your Q2 answer is incorrect"

    return True, None


def grade_ex2(q1_answer: str, q2_answer: str):
    correct, message = submit_ex2(q1_answer, q2_answer)
    if not correct:
        print(f"ðŸ˜¢ Your answer is incorrect.")
        print(f"Message from grader: {message}")

    if correct:
        print(f"ðŸŒŸ Correct! Your answers to the two questions are right!")


#####################################
# Exercise 3                        #
#####################################


def submit_ex3(
    energy_surface,
    molecule,
    num_electrons=2,
    num_molecular_orbitals=2,
    chemistry_inspired=True,
    hardware_inspired_trial=None,
    vqe=True,
    perturbation_steps=np.linspace(-1, 1, 3),
):
    _sol_num_electrons = 2  # Step 2a
    _sol_num_molecular_orbitals = 2  # Step 2a
    _sol_chemistry_inspired = True  # Step 3a
    _sol_vqe = True  # Step 3b
    _sol_perturbation_steps = np.linspace(-0.5, 5, 30)  # Step 4
    _sol_energy_surface = [
        -203.09141666161605,
        -203.30966860881864,
        -203.44886782631005,
        -203.59070098908884,
        -203.6827116359846,
        -203.73602668254733,
        -203.76432539600577,
        -203.77791004830476,
        -203.78590822917357,
        -203.79033020229178,
        -203.7956469884783,
        -203.8062427321277,
        -203.81257414160117,
        -203.81448068886868,
        -203.81474685152656,
        -203.81455055639987,
        -203.81056218302353,
        -203.81162581451514,
        -203.81214516003257,
        -203.8123931008731,
        -203.8125131151387,
        -203.812575173588,
        -203.81261141371294,
        -203.8126358813251,
        -203.81265446828453,
        -203.81266961957738,
        -203.81268240653037,
        -203.8126933632892,
        -203.81270281849527,
        -203.81271101120836,
    ]

    # Check if `chemistry_inspired` and `hardware_inspired_trial` conflict
    if chemistry_inspired and hardware_inspired_trial is not None:
        return (
            False,
            "chemistry_inspired and hardware_inspired_trial cannot both be set",
        )

    # Use submit_ex1 to check `molecule` as it must be the same as for exercise 1
    if not isinstance(molecule, Molecule):
        return False, "You didn't appear to pass a `Molecule` object instance."
    (
        geometry,
        multiplicity,
        charge,
        molecular_variation,
        atom_pair,
        masses,
    ) = serialize_molecule(molecule)
    correct, message = submit_ex1(
        geometry=geometry,
        multiplicity=multiplicity,
        charge=charge,
        molecular_variation=molecular_variation,
        atom_pair=atom_pair,
        masses=masses,
    )

    if not correct:
        return False, message

    # Check arguments for `construct_hamiltonian_solve_ground_state_plot_landscape_return_energies`
    if num_electrons != _sol_num_electrons:
        return False, "Number of electrons is incorrect"

    if num_molecular_orbitals != _sol_num_molecular_orbitals:
        return False, "Number of molecular orbitals is incorrect"

    if chemistry_inspired != _sol_chemistry_inspired:
        return False, "Your solution is not chemistry inspired"

    if vqe != _sol_vqe:
        return False, "Your solution does not use VQE"

    if np.any([a != b for a, b in zip(perturbation_steps, _sol_perturbation_steps)]):
        return False, "Pertubation steps are incorrect"

    # Check resulting energy surface is the right length
    if len(_sol_energy_surface) != len(energy_surface):
        return False, "Energy surface results do not appear to be correct"

    # Check resulting energy surface, within a given error margin
    _sol_energy_rel_error_margin = 1e-10
    _energy_rel_error = [
        np.abs(a - b) / a for a, b in zip(_sol_energy_surface, energy_surface)
    ]
    if np.any([e > _sol_energy_rel_error_margin for e in _energy_rel_error]):
        return False, "Energy surface does not appear to be correct"

    return True, None


def grade_ex3(
    energy_surface,
    molecule,
    num_electrons,
    num_molecular_orbitals,
    chemistry_inspired,
    hardware_inspired_trial,
    vqe,
    perturbation_steps,
):
    correct, message = submit_ex3(
        energy_surface,
        molecule,
        num_electrons,
        num_molecular_orbitals,
        chemistry_inspired,
        hardware_inspired_trial,
        vqe,
        perturbation_steps,
    )
    if not correct:
        print(f"ðŸ˜¢ Your answer is incorrect.")
        print(f"Message from grader: {message}")

    if correct:
        print(f"ðŸŒŸ Correct! Your energy results and function parameters are correct!")


#####################################
# Exercise 4                        #
#####################################


def submit_ex4(q1_answer, q2_answer):
    _sol_q1 = ["decrease", "decreases"]
    _sol_q2 = 4

    if q1_answer.lower() not in _sol_q1:
        return False, "Your Q1 answer is incorrect"

    if q2_answer != _sol_q2:
        return False, "Your Q2 answer is incorrect"

    return True, None


def grade_ex4(q1_answer: str, q2_answer: int):
    correct, message = submit_ex4(q1_answer, q2_answer)
    if not correct:
        print(f"ðŸ˜¢ Your answer is incorrect.")
        print(f"Message from grader: {message}")

    if correct:
        print(f"ðŸŒŸ Correct! Your answers to the two questions are right!")


#####################################
# Exercise 5                        #
#####################################


def serialize_ex5_bopess(result: BOPESSamplerResult):
    """Converts a BOPESSamplerResult object into a nested dictionary for serialization purposes.

    Args:
        result (BOPESSamplerResult): The result object from executing `construct_hamiltonian_solve_ground_state`.
    """

    from copy import deepcopy as copy

    result_dict = copy(result.__dict__)
    # Convert results into dictionaries. For this exercise, there should only be one item in `result_dict["_raw_results"].items()`. Each item is an instance of `ElectronicStructureResult`.
    result_dict["_raw_results"] = dict(
        [(k, v.__dict__) for k, v in result_dict["_raw_results"].items()]
    )

    # Convert each '_raw_result' item in the above list of results into a dictionary. Each item is a VQEResult
    for key in result_dict["_raw_results"].keys():
        result_dict["_raw_results"][key]["_raw_result"] = copy(
            result_dict["_raw_results"][key]["_raw_result"].__dict__
        )
    return result_dict


def computed_energies_ex5_are_the_same(result_dict):
    """Verify that energy_surface_result.energies[0] is the same as the underlying `raw_result` energies. energy_surface_result is a BOPESSamplerResult object with an underlying raw result object of type ElectronicStructureResult. ElectronicStructureResult has a property called `total_energies` which is the same as `energy_surface_result.energies`. This section verifies that these are the same. NB: This functions assumes only one energy value in the result objects.

    Args:
        result_dict (dict): The BOPESSamplerResult from running `construct_hamiltonian_solve_ground_state` on a specific molecule with a given ansatz, converted into a dictionary using `serialize_ex5_bopess`.
    """

    # Get provided energy
    _given_energy = result_dict["_energies"][0]

    # Compute `ElectronicStructureResult` total energy to confirm that `.energies` was not modified. Taken from https://github.com/Qiskit/qiskit-nature/blob/8a88efcccd35474d8affaef53cf16d799f9ef65b/qiskit_nature/results/electronic_structure_result.py#L82

    _electronicstructure_result_dict = result_dict["_raw_results"][0]

    #
    _electronicstructure_nuclear_energy = (
        _electronicstructure_result_dict["_nuclear_repulsion_energy"]
        if _electronicstructure_result_dict["_nuclear_repulsion_energy"] is not None
        else 0
    )

    _computed_energy = (
        _electronicstructure_result_dict["_computed_energies"][0]
        + _electronicstructure_result_dict["_extracted_transformer_energies"][
            "ActiveSpaceTransformer"
        ]
        + _electronicstructure_nuclear_energy
    )

    if _computed_energy != _given_energy:
        return False, "Something is wrong with the simulation result object"

    return True


def parameters_ex5_are_valid(
    energy_surface_result,
    molecule,
    num_electrons,
    num_molecular_orbitals,
    chemistry_inspired,
    hardware_inspired_trial: Union[
        QuantumCircuit,
        NLocal,
        TwoLocal,
        RealAmplitudes,
        PauliTwoDesign,
        EfficientSU2,
        ExcitationPreserving,
        QAOAAnsatz,
    ],
    vqe,
    perturbation_steps,
):
    """Check if the following parameters are constrained by the exercise question."""

    if chemistry_inspired:
        return False, "Simulation cannot be chemistry inspired"

    if not vqe:
        return False, "Simulation must be run using VQE"

    if perturbation_steps != [0] and perturbation_steps != np.ndarray([0]):
        return False, "Simulation must have `pertubation_steps=[0]`"

    # Check if hardware_inspired_trial is not of a suitable class type
    if (
        hardware_inspired_trial.__class__.__name__ not in ANSATZ_NAMES
        and hardware_inspired_trial.__class__.__name__ != "QuantumCircuit"
    ):
        return False, "hardware_inspired_trial is not of the correct format"

    # Verify energies are the same
    if not computed_energies_ex5_are_the_same(
        serialize_ex5_bopess(energy_surface_result)
    ):
        return False, "`energy_surface_result` appears to be corrupted"

    # Verify the molecule is correct, by executing the same grading code as for exercise 1.
    if not isinstance(molecule, Molecule):
        return False, "You didn't appear to pass a `Molecule` object instance."
    (
        geometry,
        multiplicity,
        charge,
        molecular_variation,
        atom_pair,
        masses,
    ) = serialize_molecule(molecule)
    _molecule_is_correct, _molecule_message = submit_ex1(
        geometry=geometry,
        multiplicity=multiplicity,
        charge=charge,
        molecular_variation=molecular_variation,
        atom_pair=atom_pair,
        masses=masses,
    )

    if not _molecule_is_correct:
        return False, _molecule_message

    # Check if the hardware_inspired_trial ansatz uses a maximum of 8 qubits
    if hardware_inspired_trial.num_qubits > 8:
        return False, "More than 8 qubits are used in `hardware_inspired_trial`"

    return True, None


def score_ex5(
    energy_surface_result: BOPESSamplerResult,
    molecule: Molecule,
    num_electrons,
    num_molecular_orbitals,
    chemistry_inspired,
    hardware_inspired_trial: Union[
        QuantumCircuit,
        NLocal,
        TwoLocal,
        RealAmplitudes,
        PauliTwoDesign,
        EfficientSU2,
        ExcitationPreserving,
        QAOAAnsatz,
    ],
    vqe,
    perturbation_steps,
):

    """Scores the simulated results for exercise 5. Some arguments may be invalid, in which case a score of zero is given, with the second returned parameter being the reason for the score. Scores are -10 multiplied by the order-of-magnitude of the error, rounded to the nearest integer. For an error of 1e-6, the score would be -10 * -6 = 60. Higher scores indicate smaller errors. The full quation, in LaTeX is

    $$S = \ceil{-10 \times \log_{10}{\lvert{\frac{E_{true} - E_{computed}}{E_{true}}}\rvert}}$$

    Returns:
        (int,str): A tuple containing the score and reason for any score of zero (optional).
    """

    _true_total_energy = -203.54505812928144

    _valid_parameters, _parameters_msg = parameters_ex5_are_valid(
        energy_surface_result,
        molecule,
        num_electrons,
        num_molecular_orbitals,
        chemistry_inspired,
        hardware_inspired_trial,
        vqe,
        perturbation_steps,
    )

    if not _valid_parameters:
        return 0, _parameters_msg

    _computed_energy = energy_surface_result.energies[0]
    _error = np.abs((_true_total_energy - _computed_energy) / _true_total_energy)
    _score = int(np.round(-10 * np.log10(_error)))
    return _score, None


def grade_ex5(
    energy_surface_result: BOPESSamplerResult,
    molecule: Molecule,
    num_electrons,
    num_molecular_orbitals,
    chemistry_inspired,
    hardware_inspired_trial: Union[
        QuantumCircuit,
        NLocal,
        TwoLocal,
        RealAmplitudes,
        PauliTwoDesign,
        EfficientSU2,
        ExcitationPreserving,
        QAOAAnsatz,
    ],
    vqe,
    perturbation_steps,
):

    # Retrieve the score
    score, message = score_ex5(
        energy_surface_result,
        molecule,
        num_electrons,
        num_molecular_orbitals,
        chemistry_inspired,
        hardware_inspired_trial,
        vqe,
        perturbation_steps,
    )

    correct = message is None

    if not correct:
        print(f"ðŸ˜¢ Your answer is incorrect.")
        print(f"Message from grader: {message}")

    if correct:
        print(f"ðŸŒŸ Correct! Your solution is valid.")
        print(f"You achieved a score of {score}. Try improve it as much as you can.")